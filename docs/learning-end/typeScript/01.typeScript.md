# typeScript

## 类型
## 枚举
## 接口
## 函数

## 泛型
```typescript
const identity = <T>(arg: T): T => arg;
function identities<T>(arg: T): T {
    return arg;
}

interface GenericIdentityFn<T> {
    (arg: T): T;
}
```
+ extends关键字，类型约束
```typescript
interface Lengthwise {
    length: number;
}
const loggingIdentity = <T extends Lengthwise>(arg: T): T => {
    console.log(arg.length);
    return arg;
    
    loggingIdentity({length: 10});
}
```
## 联合类型
+ &

```typescript
props & { name: string }

const isSummary = <T>(row: T & { index?: string }) =>
  row?.index === TABLE_SUMMARY_COLUMN_CODE;
```

## 类型检查
## 类型断言

-  ！符合
```typescript
const unable = detail.inv!.summary
```

-  as
-  <>
```typescript
export const reduceHandler = <T, K extends { [P in keyof T]: ProInputNumberValueType }>(
    dataSource: T[],
    key: keyof K
) => {
    return (dataSource as unknown as K[]).reduce((total, next) => plus(total, next[key]), 0);
};
```

## 高级类型

+ 索引类型
```markdown
 索引类型查询和索引访问

索引类型查询
const pluck = <T, K extends keyof T>(o: T, names: K[]): T[K][] => {
return names.map(n => o[n]);
}

interfence Maps {
name: string;
age: number;
}

const deviceInfoVosMaps = <T, K extends { [P in keyof T]: Maps }>(a: T[], b: keyof K) => {};

T[K]， 索引访问操作符
K extends keyof T

const getProperty = <T, K extends keyof T>(o: T, name: K): T[K] => {
return o[name]; // o[name] is of type T[K]
}

```